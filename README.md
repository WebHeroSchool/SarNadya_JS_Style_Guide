JS Style Guide 


1. Использовать строгое сравнение	

Операторы нестрогого равенства/неравенства (== или !=) будут приводить значения к одному типу перед сравнением. При использовании же операторов строгого равенства/неравенства (=== или !==) сравнение производится не только по значениям, но и по типам сравниваемых данных


  0 == "";        // true
  1 == "1";       // true
  1 == true;      // true

  0 === "";       // false
  1 === "1";      // false
  1 === true;     // false



2. Точка с запятой.

Точки с запятой должны присутствовать после каждого выражения, даже если их, казалось бы, можно пропустить.

Есть языки, в которых точка с запятой необязательна и редко используется. Однако в JavaScript бывают случаи, когда перенос строки не интерпретируется, как точка с запятой, что может привести к ошибкам.

Если вы, при написании кода, не используете странных конструкций, или не начинаете строку с круглой или квадратной скобки, то вы, в 99.9% случаев, не допустите ошибку (если что — вас о возможной ошибке может предупредить линтер). К «странным конструкциям», например, можно отнести такую:

return
variable




3. Отступы


Существует два типа отступов:

Горизонтальные отступы: два или четыре пробела.

Горизонтальный отступ выполняется с помощью 2 или 4 пробелов, или символа табуляции (клавиша Tab). Какой из них выбрать – это уже на ваше усмотрение. Пробелы больше распространены.

Одно из преимуществ пробелов над табуляцией заключается в том, что пробелы допускают более гибкие конфигурации отступов, чем символ табуляции.

Например, мы можем выровнять аргументы относительно открывающей скобки:

show(parameters,
     aligned, // 5 пробелов слева
     one,
     after,
     another
  ) {
  // ...
}

Вертикальные отступы: пустые строки для разбивки кода на «логические блоки».

Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация переменных, основной цикл и возвращаемый результат:


function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}

Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть более 9 строк кода подряд без вертикального отступа.



4. Уровни вложенности


Уровней вложенности должно быть немного.

Например, в цикле бывает полезно использовать директиву continue, чтобы избежать лишней вложенности.

Например, вместо добавления вложенного условия if, как здесь:

for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- ещё один уровень вложенности
  }
}

Мы можем написать:

for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- нет лишнего уровня вложенности
}

Аналогичная ситуация – с if/else и return.

Например, две нижеследующие конструкции идентичны.

Первая:

function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}

Вторая:

function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

Второй вариант является более читабельным, потому что «особый случай» n < 0 обрабатывается на ранней стадии. После проверки можно переходить к «основному» потоку кода без необходимости увеличения вложенности.



5. Размещение функций


Если вы пишете несколько вспомогательных функций, а затем используемый ими код, то существует три способа организации функций.

1. Объявить функции перед кодом, который их вызовет:

// объявление функций
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// код, который использует их
let elem = createElement();
setHandler(elem);
walkAround();

2. Сначала код, затем функции

// код, использующий функции
let elem = createElement();
setHandler(elem);
walkAround();

// --- вспомогательные функции ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

3. Смешанный стиль: функция объявляется там, где она используется впервые.

В большинстве случаев второй вариант является предпочтительным.

Это потому, что при чтении кода мы сначала хотим знать, что он делает. Если сначала идёт код, то это тут же становится понятно. И тогда, может быть, нам вообще не нужно будет читать функции, особенно если их имена хорошо подобраны.


6. Фигурные скобки


В большинстве JavaScript проектов фигурные скобки пишутся в так называемом «египетском» стиле с открывающей скобкой на той же строке, что и соответствующее ключевое слово – не на новой строке. Перед открывающей скобкой должен быть пробел, как здесь:

if (condition) {
  // делай это
  // ...и это
  // ...и потом это
}
А что если у нас однострочная запись, типа if (condition) doSomething(), должны ли мы использовать фигурные скобки?

Вот различные варианты расстановки скобок с комментариями, посмотрите сами, какой вам кажется самым читаемым:

?? Такое иногда бывает в коде начинающих. Плохо, фигурные скобки не нужны:

if (n < 0) {alert(`Степень ${n} не поддерживается`);}

?? Никогда не разделяйте строки без фигурных скобок, можно ненароком сделать ошибку при добавлении строк:

if (n < 0)
  alert(`Степень ${n} не поддерживается`);

?? В одну строку без скобок – приемлемо, если эта строка короткая:

if (n < 0) alert(`Степень ${n} не поддерживается`);

?? Самый лучший вариант:

if (n < 0) {
  alert(`Степень ${n} не поддерживается`);
}

Для очень короткого кода допустима одна строка. 
Например: 

if (cond) return null. 

Но блок кода (последний вариант) обычно всё равно читается лучше.


7. Длина строки


Никто не любит читать длинные горизонтальные строки кода. Лучше всего разбивать их, например:

// обратные кавычки ` позволяют разделять строку на части
let str = `
  Рабочая группа TC39 организации Ecma International -
  это группа JavaScript-разработчиков, теоретиков и авторов движков JavaScript,
  которые вместе с сообществом занимаются поддержкой и развитием языка JavaScript.
`;

Или для if:


if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}

Максимальную длину строки согласовывают в команде. Обычно это 80 или 120 символов.


8. Комментарии


В JavaScript можно использовать два типа комментариев. Первый тип — однострочные комментарии:

// Это комментарий

Они, как следует из названия, располагаются в одной строке. Комментарием считается всё, что идёт за символами //.

Второй тип — многострочные комментарии:

/*
Многострочный
комментарий
*/

Тут комментарием считается всё, что находится между комбинацией символов /* и */.


9. Функции


Используйте функциональные выражения вместо объявлений функций. eslint: func-style

Почему? У объявлений функций есть подъём. Это означает, что можно использовать функцию до того, как она определена в файле, но это вредит читабельности и поддержке. Если вы обнаружили, что определение функции настолько большое или сложное, что мешает понимать остальную часть файла, то, возможно, пришло время извлечь его в отдельный модуль. Не забудьте явно назвать функциональное выражение, независимо от того, подразумевается ли имя из содержащейся переменной (такое часто бывает в современных браузерах или при использовании компиляторов, таких как Babel). Это помогает точнее определять место ошибки по стеку вызовов.

// плохо
function foo() {
  // ...
}

// плохо
const foo = function () {
  // ...
};

// хорошо
// лексическое имя, отличное от вызываемой(-ых) переменной(-ых)
const foo = function uniqueMoreDescriptiveLexicalFoo() {
  // ...
};

Оборачивайте в скобки немедленно вызываемые функции. eslint: wrap-iife

Почему? Немедленно вызываемая функция представляет собой единый блок. Чтобы чётко показать это — оберните функцию и вызывающие скобки в ещё одни скобки. Обратите внимание, что в мире с модулями вам больше не нужны немедленно вызываемые функции.

// Немедленно вызываемая функция
(function () {
  console.log('Welcome to the Internet. Please follow me.');
}());

Никогда не объявляйте функции в нефункциональном блоке (if, while, и т.д.). Вместо этого присвойте функцию переменной. Браузеры позволяют выполнить ваш код, но все они интерпретируют его по-разному. eslint: no-loop-func

Примечание: ECMA-262 определяет блок как список инструкций. Объявление функции не является инструкцией.

// плохо
if (currentUser) {
  function test() {
    console.log('Nope.');
  }
}

// хорошо
let test;
if (currentUser) {
  test = () => {
    console.log('Yup.');
  };
}

Никогда не называйте параметр arguments. Он будет иметь приоритет над объектом arguments, который доступен для каждой функции.

// плохо
function foo(name, options, arguments) {
  // ...
}

// хорошо
function foo(name, options, args) {
  // ...
}

Никогда не используйте arguments, вместо этого используйте синтаксис оставшихся параметров .... eslint: prefer-rest-params

Почему? ... явно говорит о том, какие именно аргументы вы хотите извлечь. Кроме того, такой синтаксис создаёт настоящий массив, а не массивоподобный объект как arguments.

// плохо
function concatenateAll() {
  const args = Array.prototype.slice.call(arguments);
  return args.join('');
}

// хорошо
function concatenateAll(...args) {
  return args.join('');
}

Используйте синтаксис записи аргументов по умолчанию, а не изменяйте аргументы функции.

// очень плохо
function handleThings(opts) {
  // Нет! Мы не должны изменять аргументы функции.
  // Плохо вдвойне: если переменная opts будет ложной,
  // то ей присвоится пустой объект, а не то что вы хотели.
  // Это приведёт к коварным ошибкам.
  opts = opts || {};
  // ...
}

// всё ещё плохо
function handleThings(opts) {
  if (opts === void 0) {
    opts = {};
  }
  // ...
}

// хорошо
function handleThings(opts = {}) {
  // ...
}

Избегайте побочных эффектов с параметрами по умолчанию.

Почему? И так всё понятно.

var b = 1;
// плохо
function count(a = b++) {
  console.log(a);
}
count();  // 1
count();  // 2
count(3); // 3
count();  // 3

Всегда вставляйте последними параметры по умолчанию.

// плохо
function handleThings(opts = {}, name) {
  // ...
}

// хорошо
function handleThings(name, opts = {}) {
  // ...
}

Никогда не используйте конструктор функций для создания новых функий. eslint: no-new-func

Почему? Создание функции в таком духе вычисляет строку подобно eval(), из-за чего открываются уязвимости.

// плохо
var add = new Function('a', 'b', 'return a + b');

// всё ещё плохо
var subtract = Function('a', 'b', 'return a - b');

Отступы при определении функции. eslint: space-before-function-paren space-before-blocks

Почему? Однородность кода — это хорошо. Вам не надо будет добавлять или удалять пробел при манипуляции с именем.

// плохо
const f = function(){};
const g = function (){};
const h = function() {};

// хорошо
const x = function () {};
const y = function a() {};

Никогда не изменяйте параметры. eslint: no-param-reassign

Почему? Манипуляция объектами, приходящими в качестве параметров, может вызывать нежелательные побочные эффекты в вызывающей функции.

// плохо
function f1(obj) {
  obj.key = 1;
}

// хорошо
function f2(obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
}

Никогда не переназначайте параметры. eslint: no-param-reassign

Почему? Переназначенные параметры могут привести к неожиданному поведению, особенно при обращении к arguments. Это также может вызывать проблемы оптимизации, особенно в V8.

// плохо
function f1(a) {
  a = 1;
  // ...
}

function f2(a) {
  if (!a) { a = 1; }
  // ...
}

// хорошо
function f3(a) {
  const b = a || 1;
  // ...
}

function f4(a = 1) {
  // ...
}

Отдавайте предпочтение использованию оператора расширения ... при вызове вариативной функции. eslint: prefer-spread

Почему? Это чище, вам не нужно предоставлять контекст, и не так просто составить new с apply.

// плохо
const x = [1, 2, 3, 4, 5];
console.log.apply(console, x);

// хорошо
const x = [1, 2, 3, 4, 5];
console.log(...x);

// плохо
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));

// хорошо
new Date(...[2016, 8, 5]);

Функции с многострочным определением или запуском должны содержать такие же отступы, как и другие многострочные списки в этом руководстве: с каждым элементом на отдельной строке, с запятой в конце элемента. eslint: function-paren-newline

// плохо
function foo(bar,
             baz,
             quux) {
  // ...
}

// хорошо
function foo(
  bar,
  baz,
  quux,
) {
  // ...
}

// плохо
console.log(foo,
  bar,
  baz);

// хорошо
console.log(
  foo,
  bar,
  baz,
);



10. Блоки


Используйте фигурные скобки, когда блок кода занимает несколько строк. eslint: nonblock-statement-body-position

// плохо
if (test)
  return false;

// хорошо
if (test) return false;

// хорошо
if (test) {
  return false;
}

Если блоки кода в условии if и else занимают несколько строк, расположите оператор else на той же строчке, где находится закрывающая фигурная скобка блока if. eslint: brace-style

// плохо
if (test) {
  thing1();
  thing2();
}
else {
  thing3();
}

// хорошо
if (test) {
  thing1();
  thing2();
} else {
  thing3();
}